#타입스크립트에서 타입을 뺐을때 정상 동작하는 js코드여야한다!

## 타입 추론
const a: string = "abc" 과 같은 타입 선언은 문제의 여지가 있다.
<br> "abc"라는 정확한 타입을 주었다가 string으로 변경되기 때문이다.<br> 굳이 해줄 필요가 없다.
타입스크립트가 추론을 잘못했을때만 고쳐주면 된다.<br>
매개변수에는 반드시 타입을 붙여주는 것이 좋다. return 값은 매개변수의 타입값을 기반으로 타입 추론을 하기 떄문.<br>
추론을 잘해주면 추론에 맡기자.

interface = 객체지향 type = 마음대로 쓸 수 있다.
interface는 같은이름으로 재지정 할 수 있어 확장성이 좋다.

잉여속성검사 

void의 두가지 사용법
1. 함수의 직접적인 return 값이 void인 경우에만 에러가난다.
2. 매개 변수와 method에서는 크게 상관이없다 (return 값이 있어도 사용하지 않겠다는 뜻.)

as를 이용해 타입을 강제 변환 하는 법

any 를 쓸 바에 unknown을 쓰자

타입가드
타입을 구분해주는 커스텀 함수를 직접 만들 수 있다. (is 가 들어감)
is의 용법?

빈객체 타입 = 모든타입
Object 타입 = 모든타입 (null과 undefined 제외)

인덱스드 시그니쳐 [key: string]: number
class는 그자체로 타입이 될 수 있다.
하지만 class를 타입으로 지정해 주게 되면 new A를 해야하고
class의 타입을 잡아주는건 typeof 를 쓰면 된다.

implements 
private = 상속받았을 때 사용불가
protected = 상속 받았을 때 사용 가능

class의 장점: 그 자체로 타입이기 때문에 바로 사용 할 수 있고, js에 남아있다.
가져다 쓰고 싶을때는 class, 필요없을때는 interface

abstract class로 추상 클래스를 만들 수 있다.

제네릭
지금 타입이 뭔지는 몰라요. 나중에 정할래요 (타입을 변수처럼 만듦).
제네릭 함수에 타입을 제한 하는법.
extends로 제한한다.

타입가드 하는법
원시타입의 typeof
클래스객체의 instanceof

인터페이스 타입에일리어스 클래스도 제네릭 사용이 가능하다.
